---
title: "우아한테크세미나 코프링 정리"
description: "코틀린을 스프링에도 본격적으로 활용해보자!"
date: "2021-09-29T17:49:24.240Z"
categories: []
published: true
canonical_link: https://medium.com/@jaeyeong951/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%84%B8%EB%AF%B8%EB%82%98-%EC%BD%94%ED%94%84%EB%A7%81-%EC%A0%95%EB%A6%AC-eca1ddb337b5
redirect_from:
  - /우아한테크세미나-코프링-정리-eca1ddb337b5
---

코틀린을 스프링에도 본격적으로 활용해보자!

undefined

이 포스트는 2021년 9월 29일 진행된 **박재성님의** 우아한테크세미나 **‘어디가서 코프링 매우 알은 체하기'**를 제 나름대로 정리한 글입니다.

### 코틀린 표준 라이브러리를 익히고 사용하라.

-   예를 들면, 코틀린은 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공 한다. → 자바는 하나(Collection)

### 코틀린에서 자바와 관련된 import 를 없애자.

### 항상 자바로 역컴파일하는 습관을 들이자.

### 코틀린은 어떻게 자바와 같이 사용이 가능할까?

-   (\*.kt, _.java) → 코틀린 컴파일러가 코틀린 먼저 컴파일 → (_.class, \*.java) → 자바 컴파일 & 어노테이션 프로세싱 → \*.class

### 롬복 대신 data class를 사용하자.

-   롬복이 생성한 자바 코드는 코틀린 클래스에서 접근 불가능
-   어노테이션 프로세싱이 코틀린 컴파일 이후에 수행되기 때문
-   이를 해결하기 위해 코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조절하면 롬복 문제는 해결할 수 있지만
-   반대로 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.
-   코드가 간결하기 때문에 한 코틀린 파일에 여러 관련 클래스를 담는 것도 좋은 방법이다.
-   코틀린 1.5 부터 자바 16의 레코드 클래스도 지원한다.

undefinedundefined

### Spring Boot

undefined

-   위 코드는 컴파일에 실패한다.
-   코틀린의 class 는 기본적으로 final 이다. 하지만 스프링에서 configuration 관련 클래스들은 final 이어서는 안된다.(@SpringBootApplication 어노테이션은 @Configuration 어노테이션을 포함)(@Configuration 어노테이션은 CGLIB 을 사용하여 해당 클래스에 대한 프록시를 생성)
-   이 때 CGLIB 은 대상 클래스를 상속하여 프록시를 만들게 되는데, final 클래스와 함수는 상속하거나 override 할 수 없으므로 프록시를 생성할 수 없다.
-   코틀린에서 상속을 허용하려면 open 변경자를 추가해야 한다.
-   스프링 프레임워크 5.2 부터는 @Configuration의 ProxyBeanMethod 옵션을 사용하여 프록시 생성을 비활성화 할 수 있다.
-   하지만 스프링을 사용하는 경우 프록시 기반의 어노테이션이 굉장히 많은데(Transactional, Cachable, Test 등) 매번 open 변경자를 추가하는 것은 코틀린을 장점을 많이 퇴색시키는 것이 아닌가?

### All-open 컴파일러 플러그인

-   코틀린이 제공하는 다양한 컴파일러 플러그인 중 하나
-   all-open 컴파일러 플러그인은 지정한 어노테이션이 있는 클래스와 모든 멤버에 open 변경자를 자동으로 추가해준다.
-   스프링을 사용하는 경우 all-open 컴파일러 플러그인을 래핑한 kotlin-spring 컴파일러 플러그인을 사용할 수 있다.
-   @Component, @Transactional, @Async 등이 기본적으로 제공된다.

### jackson-kotlin 모듈

-   잭슨은 역직렬화 과정을 위해 매개변수가 없는 생성자를 반드시 필요로 한다.
-   코틀린에서 매개변수가 없는 생성자를 만들려면 생성자의 모든 매개변수에 기본값을 지정해주어야 한다.
-   잭슨 코틀린 모듈은 매개변수가 없는 생성자가 없더라도 직렬화와 역직렬화를 지원한다.

### 코틀린 어노테이션

undefined

-   코틀린에서 클래스 이름 옆에 val 이나 var 로 선언된 변수들은 자바로치면 4 가지 역할을 수행한다.

1.  필드
2.  게터
3.  세터
4.  생성자 파라미터

-   그래서 JsonProperty 와 같은 어노테이션을 붙일 때 게터나 세터와 같이 조금 더 세세하게 다루고 싶을 경우에는 위처럼 사용하면 된다.

### 우선은 변경 가능성을 제한하자.

-   우선은 val 로 선언하고 추후에 변경 가능성이 필요한 경우에 var 로 변경하자.
-   스프링 부트 2.2 부터 스프링 프로퍼티 클래스에서 생성자 바인딩을 사용할 수 있다.
-   생성자 바인딩을 사용하려면 @EnableConfigurationProperies 또는 @ConfigurationPropertiesScan 어노테이션을 사용하자.
-   클래스에 개념적으로 동일하지만 하나는 공개된 API의 일부이고 다른 하나는 구현 세부 사항인 두 개의 프로퍼티가 있는 경우 private 프로퍼티의 이름의 접두사로 밑줄을 사용한다.
-   이를 뒷받침 프로퍼티(Backing Property) 라고 한다.
-   JVM 에서는 기본 게터 및 세터가 있는 private 프로퍼티에 대해 함수 호출 오버헤드를 방지하도록 최적화되어있다.

undefined

-   위 코드의 경우 students 프로퍼티는 실제 필드(Backing Field)가 생성이 되지 않음
-   코틀린과 JPA를 사용하게 될 때, OneToMany 로 일대다 연관관계를 맺게 되는데 이 때 Mutable Collection 을 private 으로 만들어서 CUD 동작을 숨기고 Backing Property 를 이용해 Read 시 Immutable Collection 을 리턴하자.

### Persistence

### No-arg 컴파일러 플러그인

-   JPA 에서 엔티티 클래스를 생성하려면 매개변수가 없는 생성자가 필요하다.
-   no-args 컴파일러 플러그인은 지정한 어노테이션이 있는 클래스에 매개변수가 없는 생성자를 자동으로 추가해준다.
-   kotlin-spring 컴파일러 플러그인과 마찬가지로 JPA를 사용하는 경우 no-args 컴파일러 플러그인을 래핑한 kotlin-jpa 플러그인을 사용할 수 있다.
-   @Entity, @Embeddable, @MappedSuperClass 가 기본적으로 제공된다.
-   Entity 와 MappedSuperClass 어노테이션에 all-open 이 필요한 이유?

undefined

-   JPA 가 프록시 객체를 못만들기 때문 → 이는 곧 지연 로딩을 할 수 없게된다는 말
-   성능상의 문제가 발생할 수 있음 → 당장 필요없는 클래스들을 모두 로딩하기 때문

### 엔티티에 data class 사용을 피하라

-   양방향 연관 관계의 경우 toString() 이나 hashCode() 를 호출할 때 순환 참조가 발생한다.

### 사용자 지정 getter 를 사용하라

-   영속화하지 않는 필드는 초기화된 프로퍼티가 아닌 사용자 지정 게터를 사용해야한다.
-   JPA에 의해 인스턴스화 될 때는 초기화 블록이 호출되지 않기 때문에 영속화 하지 않는 필드는 초기화된 프로퍼티가 아닌 사용자 지정 getter 를 사용해야 한다.

undefined

-   위의 코드의 경우 왼쪽 코드를 보면 @Transient 어노테이션이 붙은 것으로 보아 영속화하지 않겠다는 뜻으로 보인다.
-   하지만 위처럼 등호를 사용하여 초기화 코드로 관리를 하게되면 나중에 인스턴스화 되어 값을 꺼낼 때 아무 값이 들어있지 않다. nullable 이 아님에도 말이다. → JPA 에 의해 인스턴스화 되기 때문
-   사용자 지정 게터를 정의해서 프로퍼티에 접근 할 때 마다 계산되도록 수정 하자.
-   커스텀 게터를 사용하면 Backing Field 가 없기 때문에 굳이 @Transient 어노테이션을 사용할 필요가 없다.

### Backing Field 란?

-   Field 란 프로퍼티의 일부로서 메모리에 저장된 프로퍼티의 value 자체를 의미한다,
-   Backing Field 는 프로퍼티가 필요로 할 때 자동으로 생성되는데, 세터나 게터에서 field 라는 이름으로 접근 가능하다.

```
var counter = 0 // 세터로 backing field 에 직접적으로 접근
    set(value) {
        if (value >= 0)
            field = value
            // counter = value
            // StackOverflow 에러 발생 : 실제 변수 이름인 'counter' 로 접근은 세터를 recursive 하게 계속 호출한다.
    }
```

-   Backing Field 는 해당 프로퍼티의 게터나 세터 중 하나라도 기본 구현체 그대로 사용하거나,
-   커스텀 게터, 세터가 field 라는 이름으로 접근할 때 생성된다.
-   다음과 같은 경우, 프로퍼티는 backing field 가 없다.

```
val isEmpty: Boolean
    get() = this.size == 0
```

### **위 까지가 코틀린 공식 문서의 설명이고, 내가 이해한 바는 아래와 같다.**

-   자바에서의 field 의 개념이 코틀린에서 프로퍼티의 개념과 동일하다고 보면 될 듯 하다.
-   코틀린에서 `var a = 1` 이라는 코드를 보면 a라는 '프로퍼티'를 선언하고 1 로 초기화한다.
-   이후에 `a = 2` 라는 코드를 호출하면 이는 자바로 따지면 a의 세터를 호출한 것이지 a의 필드를 직접적으로 2로 바꾸는 코드가 아니다.
-   자바의 경우 a 자체가 필드를 의미하기 때문에 자바에서 `a = 2` 의 경우 a의 필드를 직접적으로 2로 바꾸는 코드가 된다.

#### 널이 될 수 있는 타입을 빠르게 제거하라.

-   널이 될 수 있는 타입은 매번 널 검사를 하거나 !! 를 추가해야한다.
-   0 또는 빈 문자열로 초기화하면 널이 될 수 있는 타입을 제거할 수 있다.

### gradle 파일에 groovy 가 아닌 코틀린 DSL 을 사용하자.

-   코틀린 DSL의 장점으로는 타입을 먼저 체크한다든가, 자동완성이나, 구문의 문제점을 미리 파악할 수 있다는 점이다.
-   SpringSecurity 또한 코틀린 DSL 로 작성할 수 있다.

undefined

-   Test 코드도 코틀린 DSL 로 작성할 수 있다.
-   Mockito 의 코틀린 버전인 MockK 를 주로 사용 (mockito 는 확장함수에 대한 stubbing 이 불가능)
-   아주 간결한 테스트 코드를 작성할 수 있다.

### 확장 함수의 활용

-   Repository 에 확장함수를 활용해보자.

undefined

-   JPA를 사용하다보면 함수이름이 지나치게 길어지는 경우가 있는데, 보통은 쿼리 어노테이션으로 쿼리를 직접 짜서 해결하지만 확장 함수로 간단하게 해결 가능하다.

### Kotlin lint 로 컨벤션을 관리하자

-   코틀린 스타일 가이드를 적용해준다.
-   그래들에 task 가 추가됨 → 정적 분석을 수행 (안드로이드 진영에는 android lint 가 존재)
-   커밋시에 린트 체크 하도록 hook 을 추가할 수도 있다.

### 코틀린은 공식 문서가 굉장히 잘 되어 있다. 많이 참고하자.

-   자바 오라클 공식 문서처럼 못생기고 불친절하지 않다.

---

코틀린을 이제야 1년 조금 넘게 공부했고, 아직도 자바를 비롯해서 배울 것이 너무나 많다. 어느정도 활용은 할 수 있는 수준은 됐을거라 생각했지만, 재성님의 예시 코드를 보니 아직 멀었구나 싶다. 보고 많이 참고해야 겠다.
